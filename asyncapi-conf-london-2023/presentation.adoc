= AsyncAPI and Modelina
:revealjs_theme: sky
:revealjs_transition: slide
:imagesdir: images

Enforce Contracts And Reduce Boilerplate +
 +
 +

Artur Ciocanu +
GitHub: @artur-ciocanu +
Twitter: @artur_ciocanu

== Introduction

* Part of Adobe Journey Optimizer
* In marktech for the last 8 years
* Polyglot developer
* Tech Lead and Architect for Adobe Journey Optimizer Edge Delivery

[.notes]
--
Hello everyone, my name is Artur and I work for Adobe Journey Optimizer. I've been in the marktech technology space for the last 8 years.I'm a polyglot developer and architect for Adobe Journey Optimizer Edge Delivery.

Before we get started, I'd like to thank the organizers for giving me the opportunity to speak today and I want to thank the sponsors for making this event possible.
--

== Background
Adobe Journey Optimizer::
* Cloud based solution
* Personalized experiences at scale
* Omni-channel
* Right content at the right time

[.notes]
--
Before we delve into AsyncAPI and Modelina, I'd like to give you a bit of background about Adobe Journey Optimizer. Like many modern cloud solutions Adobe Journey Optimizer is based on a microservices architecture. We have quite a few applications running on the "edge". Running on the "edge" means that we are as close to our customer's customers as possible. To make sure that we deliver the right experience at the right time we need to ensure that "config" data like marketing campaigns, offers, and other business rules are available to our applications. Data is pushed from "hubs" to "edges" via Kafka.
--

== Edge Network
image::edge-network.png[]

[.notes]
--
Here is quick overview of our current Edge Network. On the edge we have different applications that are covering different use cases like: personalization, experimentation, Machine Learning, etc. All these applications are consuming config data tha is published via Kafka.
--

== The Mess
image::confluence.jpg[width=600,height=500]

[.notes]
--
Like most enterprises are go to solution for documenting architecture, onboarding and other engineering related processes, including integration details, is Confuence. We have Confluence pages that describe the data that is sent to Kafka. These pages are manually maintained by engineers. This is a very error prone process. Engineers are not always up to date with the latest changes and the documentation is not always accurate. This leads to a lot of confusion and frustration. 
--

== The Mess
image::json.png[width=600,height=400]

[.notes]
--
Some teams are using JSON Schema to document the payload that is sent over Kafka, however most of the time we see just some JSON samples in the WIKI and some tables with the field names and types. This is not very helpful for the consumers of the data. 
--

== The Mess
image::aaron-blanco-tejedor-VBe9zj-JHBs-unsplash.jpg[width=600,height=400]

[.notes]
--
This leads to pain, suffering and agony, since the only source of truth is the code that actually sends the data over the wire instead of the WIKI pages.
--

== The Mess
image::confluence-json-example.png[width=700,height=400]

[.notes]
--
Here is a quick example of a Conflunce page with some JSON sample.
--

== The Zen
image::asyncapi.jpg[width=500,height=500]

[.notes]
--
We are at an AsyncAPI conf so you might have guessed that the solution to our pain and suffering is AsyncAPI. It should be noted that at Adobe we are heavy users of OpenAPI, but for whatever reason AsyncAPI flew under the radar for some time.
--

== The Zen
image::kafka.png[width=300,height=500]

[.notes]
--
As I already mentioned we are heavy users of Kafka. It is our go to messaging solution, but we are considering using AsyncAPI in other places where teams are using RabbitMQ, AWS SQS, JMS, etc.
--

== The Zen
image::heart.png[width=600,height=500]

[.notes]
--
We love AsyncAPI, it helped my team and we are actively evangelizing it within Adobe, we'll see how it goes :).
--

== The Zen
AsyncAPI killer features::
- Human readable
- Machine readable
- Awesome tooling
- Awesome community
- Extremely extensible and flexible

[.notes]
--
Just like OpenAPI, AsyncAPI is human and machine readable. It has awesome tooling and an awesome community. It is extremely extensible and flexible. Being part of Linux Foundation is a huge plus. We can be confident that AsyncAPI will thrive and we can bet on it.
--

== The Zen
image::asyncapi-docs.png[width=700,height=400]

== Modelina
image::ring-of-power.png[width=900,height=600]

[.notes]
--
So far I have been talking about AsyncAPI, however one of the reason that AsyncAPI was so successful within our teams is due to Modelina. Modelina proved to be quite a versatile tool. As I mentioned we are using OpenAPI quite heavily along with OpenAPI Generator. What we really liked about Modelina is that we can use one code-gen tool for OpenAPI, JSON Schema, AsyncAPI, which means that we can standardize on one tool.
--

== Modelina
Use cases::
- Generate classes from OpenAPI for the REST API
- Generate classes from AsyncAPI for Kafka publishing and consuming
- Generate classes from JSON Schema to store them in document DBs like MongoDB or CosmosDB

[.notes]
--
It is worth noting that while initially we intended to use Modelina just for AsyncAPI and Kafka we quickly realized that we can use it to automate code generation for our REST and data layer and use OpenAPI, JSON Schema and AsyncAPI as the source of truth. 
--

== Demo
image::architecture.png[width=1000,height=600]

[.notes]
--
To make sure we are on the same page, here is a quick diagram showing the services that we are going to use in the demo. We have a service that is publishing data to Kafka and another service that is consuming the data from Kafka.
--

== Demo - services
Services::
- Kotlin Producer App
- Java Consumer App
- Scala Consumer App

== Demo - services
Service structure::
- `api/spec` - OpenAPI specification
- `api/external-specs` - AsyncAPI specifications
- `api/config` - code generation configuration

[.notes]
--
It should be noted that this structure is NOT enforced in any way. It is just a convention that we are using. To help teams to the right thing we have a GitHub template repository that they can use to bootstrap their services.
--

== Demo - for real :)
image::show-time.png[width=900,height=500]
